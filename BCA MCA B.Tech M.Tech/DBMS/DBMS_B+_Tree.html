<html>
<head>
<title>NETCODE</title>

<meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.0/css/bootstrap.min.css">
  <link href="https://fonts.googleapis.com/css?family=Montserrat" rel="stylesheet">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.0/js/bootstrap.min.js"></script>

<script src="jquery-3.4.1.min.js"></script>

<style>
.con .homecontent{
	float:left;
     background:#dfe5ed;
     margin:4;
}
element.style {
}
.ddsmoothmenu {
    font-size: 13px;
    background-color: #787c7d;
    width: 100%;
}

div {
    display: block;
}
html {
    color: -internal-root-color;
}
.ddsmoothmenu ul li a {
    display: block;
    background-color: #787c7d;
    color: #fff;
    font-size: 15px;
    padding: .9em;
    text-decoration: none;
}
a {
    color: green;
    text-decoration: none;
}
.ddsmoothmenu ul li a:hover{
	display: block;
	background-color:#4d5354;
}

.ddsmoothmenu ul {
    z-index: 100;
    margin: 0;
    padding: 0;
    list-style-type: none;
}
ul, ul.points {
    list-style: circle;
    line-height: 150%;
}
ul {
    list-style-type: disc;
}
.ddsmoothmenu {
    font-size: 13px;
    background-color: #787c7d;
    width: 100%;
}

  #link {
        height: 46px;
        font-weight: 700;
        overflow: hidden
    }

element.style {
    clear: both;
}
div {
    display: block;
}
div ul li.cen
{
	float:left;
}
html {
    color: -internal-root-color;
}
.homecontent {
    
    font-size: 14px;
    padding: 15px;
    width:  300px;
    height: 174px;
    border-radius: 2px 25px 2px 25px;
    -webkit-box-shadow: -2px 10px 22px -16px rgba(0,0,0,.75);
    -moz-box-shadow: -2px 10px 22px -16px rgba(0,0,0,.75);
    box-shadow: 7px 10px 22px -6px rgba(0,0,0,.75);
}

#innerfooter div, #interview h2, #uh3, .homecontent, div#q h2, div.q h2 {
    text-align: center;
}
user agent stylesheet
.homecontent div {
    display: block;
}
.homecontent div a {
    color: green;
    text-decoration: none;
}
user agent stylesheet
a:-webkit-any-link {
    color: -webkit-link;
    cursor: pointer;
}
#city td {
    color: #000;
    line-height: 23px;
    margin-left: 20px;
}
#city td, #city ul {
    font: 13px verdana,helvetica,arial,sans-serif;
}
user agent stylesheet
table {
    border-collapse: separate;
    border-spacing: 2px;
}
/*button next & previes */
#bottomnextup a {
    font: 13px/1.5 times new roman;
    background-color: #787c7d;
    float: right;
    margin-top:5px;
    padding: 6px 25px;
    color: #fff;
    font-weight: 700;
    text-decoration: none;
    margin-left: 7px;
}
#bottomnextup a:hover{
    display: block;
    background-color:#4d5354;   
}
.Content_Only
{
    background-color:#e5ecee;
    margin-left: inherit;
    margin-right: auto;
}

@media screen and (min-width: 700px){
.Content_Only {
    margin-left:200px;
    margin-right: 100px;
}

.h3 {
    font-size: 21px;
}
.h3, .h4 {
    font-family: erdana,helvetica,arial,sans-serif;
    color: #610B4B;
}
.h1, .h3 {
    font-weight: 400;
}
h1, h2, h3 {
    line-height: 1.3em;
}

h3 {
    display: block;
    font-size: 1.17em;
    margin-block-start: 1em;
    margin-block-end: 1em;
    margin-inline-start: 0px;
    margin-inline-end: 0px;
    font-weight: bold;
}
</style>

</head>
<body>

<div id="link" style="clear:both"> 
	<div class="ddsmoothmenu"><ul>
        <li class="cen"><a href="#">NETCODE</a></li>
		<li class="cen"><a href="https://www.javatpoint.com">DS</a></li>
		<li class="cen"><a href="python-tutorial">DAA</a></li>
		<li class="cen"><a href="java-tutorial">OS</a></li>
		<li class="cen"><a href="php-tutorial">C.Network</a></li>
		<li class="cen"><a href="javascript-tutorial">Compiler D:</a></li>
        <li class="cen"><a href="javascript-tutorial">COA</a></li>
        <li class="cen"><a href="javascript-tutorial">D.Math</a></li>
        <li class="cen"><a href="javascript-tutorial">E.Hacking</a></li>
        <li class="cen"><a href="javascript-tutorial">C.Graphics</a></li>
        <li class="cen"><a href="javascript-tutorial">Software E.</a></li>
        <li class="cen"><a href="javascript-tutorial">Web Tech</a></li>
        <li class="cen"><a href="javascript-tutorial">Cyber Sec</a></li>
        <li class="cen"><a href="javascript-tutorial">Automata </a></li>
        <li class="cen"><a href="javascript-tutorial">C</a></li>
        <li class="cen"><a href="javascript-tutorial">C++</a></li>
        <li class="cen"><a href="javascript-tutorial">Java</a></li>
        <li class="cen"><a href="javascript-tutorial">.Net</a></li>
        <li class="cen"><a href="javascript-tutorial">Python</a></li>
        <li class="cen"><a href="javascript-tutorial">Programs</a></li>
        <li class="cen"><a href="javascript-tutorial">Control S.</a></li>

	</ul><br style="clear: left"></div> 
</div>
<div class="Content_Only">
    <table>
<tr><td>

<div id="bottomnextup">
<a class="next" href="dbms-er-model-concept">next &rarr;</a>
<a class="next" href="dbms-data-independence">&larr; prev</a>
</div>


<h2>Introduction</h2>
<p>As we have already seen in previous articles that B+ tree is a (key, value) storage method in a tree like structure. B+ tree has one root, any number of intermediary nodes (usually one) and a leaf node. Here all leaf nodes will have the actual records stored. Intermediary nodes will have only pointers to the leaf nodes; it not has any data. Any node will have only two leaves. This is the basic of any B+ tree.</p>
<p>Consider the STUDENT table below. This can be stored in B+ tree structure as shown below. We can observe here that it divides the records into two and splits into left node and right node. Left node will have all the values less than or equal to root node and the right node will have values greater than root node. The intermediary nodes at level 2 will have only the pointers to the leaf nodes. The values shown in the intermediary nodes are only the pointers to next level. All the leaf nodes will have the actual records in a sorted order.</p>
<p><img style="width: auto; max-width: 100%; height: auto;" src="../images/dbms/42/1.png" alt="" width="697" height="401" /></p>
<p>If we have to search for any record, they are all found at leaf node. Hence searching any record will take same time because of equidistance of the leaf nodes. Also they are all sorted. Hence searching a record is like a sequential search and does not take much time.</p>
<p>Suppose a B+ tree has an order of n (it is the number of branches &ndash; above tree structure has 5 branches altogether, hence order is 5), and then it can have n/2 to n intermediary nodes and n/2 to n-1 leaf nodes. In our example above, n= 5 i.e.; it has 5 branches from root. Then it can have intermediary nodes ranging from 3 to 5. And it can have leaf nodes from 3 to 4.</p>
<p><img style="width: auto; max-width: 100%; height: auto;" src="../images/dbms/42/2.png" alt="" width="411" height="127" /></p>
<h3>The main goal of B+ tree is:</h3>
<ul type="disc">
<li><strong>Sorted Intermediary and leaf nodes:</strong> Since it is a balanced tree, all nodes should be sorted.</li>
<li><strong>Fast traversal and Quick Search:</strong></li>
</ul>
<p>One should be able to traverse through the nodes very fast. That means, if we have to search for any particular record, we should be able pass through the intermediary node very easily.&nbsp; This is achieved by sorting the pointers at intermediary nodes and the records in the leaf nodes.</p>
<p>Any record should be fetched very quickly. &nbsp;This is made by maintaining the balance in the tree and keeping all the nodes at same distance.</p>
<ul type="disc">
<li><strong>No overflow pages:</strong> B+ tree allows all the intermediary and leaf nodes to be partially filled &ndash; it will have some percentage defined while designing a B+ tree. This percentage up to which nodes are filled is called fill factor. &nbsp;If a node reaches the fill factor limit, then it is called overflow page. If a node is too empty then it is called underflow. In our example above, intermediary node with 108 is underflow. And leaf nodes are not partially filled, hence it is an overflow. In ideal B+ tree, it should not have overflow or underflow except root node.</li>
</ul>
<h2><strong>Searching a record in B+ Tree</strong></h2><p><script async src=//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script><ins class=adsbygoogle style=display:block data-ad-format=fluid data-ad-layout-key=-ej+6g-15-c4+qd data-ad-client=ca-pub-1174731959844189 data-ad-slot=2677109434></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({});</script></p>
<p>Suppose we want to search 65 in the below B+ tree structure. First we will fetch for the intermediary node which will direct to the leaf node that can contain record for 65. So we find branch between 50 and 75 nodes in the intermediary node. Then we will be redirected to the third leaf node at the end. Here DBMS will perform sequential search to find 65. Suppose, instead of 65, we have to search for 60. What will happen in this case? We will not be able to find in the leaf node. No insertions/update/delete is allowed during the search in B+ tree.</p>
<p><img style="width: auto; max-width: 100%; height: auto;" src="../images/dbms/42/3.png" alt="" width="620" height="147" /></p>
<h2><strong>Insertion in B+ tree</strong></h2><p><script async src=//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script><ins class=adsbygoogle style=display:block data-ad-format=fluid data-ad-layout-key=-ej+6g-15-c4+qd data-ad-client=ca-pub-1174731959844189 data-ad-slot=2677109434></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({});</script></p>
<p>Suppose we have to insert a record 60 in below structure. It will go to 3<sup>rd</sup> leaf node after 55. Since it is a balanced tree and that leaf node is already full, we cannot insert the record there. But it should be inserted there without affecting the fill factor, balance and order. So the only option here is to split the leaf node. But how do we split the nodes?&nbsp;</p>
<p><img style="width: auto; max-width: 100%; height: auto;" src="../images/dbms/42/4.png" alt="" width="607" height="169" /></p>
<p>The 3rd leaf node should have values (50, 55, 60, 65, 70) and its current root node is 50. We will split the leaf node in the middle so that its balance is not altered. So we can group (50, 55) and (60, 65, 70) into 2 leaf nodes. If these two has to be leaf nodes, the intermediary node cannot branch from 50. It should have 60 added to it and then we can have pointers to new leaf node.</p>
<p><img style="width: auto; max-width: 100%; height: auto;" src="../images/dbms/42/5.png" alt="" width="684" height="167" /></p>
<p>This is how we insert a new entry when there is overflow. In normal scenario, it is simple to find the node where it fits and place it in that leaf node.</p>
<h2><strong>Delete in B+ tree</strong></h2>
<p>Suppose we have to delete 60 from the above example. What will happen in this case? We have to remove 60 from 4<sup>th</sup> leaf node as well as from the intermediary node too. If we remove it from intermediary node, the tree will not satisfy B+ tree rules. So we need to modify it have a balanced tree. After deleting 60 from above B+ tree and re-arranging nodes, it will appear as below.&nbsp;</p>
<p><img style="width: auto; max-width: 100%; height: auto;" src="../images/dbms/42/6.png" alt="" width="610" height="144" /></p>
<p>Suppose we have to delete 15 from above tree. We will traverse to the 1<sup>st</sup> leaf node and simply delete 15 from that node. There is no need for any re-arrangement as the tree is balanced and 15 do not appear in the intermediary node.</p>
<p><img style="width: auto; max-width: 100%; height: auto;" src="../images/dbms/42/7.png" alt="" width="602" height="135" /></p>
<h2>B+ Tree Extensions</h2><p><script async src=//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script><ins class=adsbygoogle style=display:block data-ad-format=fluid data-ad-layout-key=-ej+6g-15-c4+qd data-ad-client=ca-pub-1174731959844189 data-ad-slot=2677109434></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({});</script></p>
<p>As the number of records grows in the database, the intermediary and leaf nodes needs to be split and spread widely to keep the balance of the tree. This is called as B+ tree extensions. As it spreads out widely, the searching of records becomes faster.</p>
<p>The main goal of creating B+ tree is faster traversal of records. As the branches spreads out, it requires less I/O on disk to get the record.&nbsp; Record that needs to be fetched are fetched in logarithmic fraction of time.&nbsp; Suppose we have K search key values &ndash; that is the pointers in the intermediary node for n nodes. Then we can fetch any record in the b+ tree in log <sub>(n/2) </sub>(K).</p>
<p>Suppose each node takes 40bytes to store an index and each disk block is of 40Kbytes. That means we can have 100 nodes (n).&nbsp; Say we have 1million search key values &ndash; that means we have 1 million intermediary pointers. Then we can access log <sub>50 </sub>(1000000) = 4 nodes are accessed in one go. Hence this costs only 4milliseconds to fetch any node in the tree. Now we can guess the advantage of extending the B+ tree into more intermediary nodes. As intermediary nodes spread out more and more, it is more efficient in fetching the records in B+ tree.</p>
<p>Look at below two diagrams to understand how it makes difference with B+ tree extensions.</p>
<p><img style="width: auto; max-width: 100%; height: auto;" src="../images/dbms/42/8.png" alt="" width="638" height="376" /></p>
<h2>B+ Tree index files</h2>
<p>Above concept of B+ tree is used to store the records in the secondary memory. If the records are stored using this concept, then those files are called as B+ tree index files.&nbsp; Since this tree is balanced and sorted, all the nodes will be at same distance and only leaf node has the actual value, makes searching for any record easy and quick in B+ tree index files. Even insertion/deletion in B+ tree does not take much time. Hence B+ tree forms an efficient method to store the records.</p>
<p>Searching, inserting and deleting a record is done in the same way we have seen above. Since it is a balance tree, it searches for the position of the records in the file, and then it fetches/inserts /deletes the records. In case it finds that tree will be unbalanced because of insert/delete/update, it does the proper re-arrangement of nodes so that definition of B+ tree is not changed.</p>
<p>Below is the simple example of how student details are stored in B+ tree index files.</p>
<p><img style="width: auto; max-width: 100%; height: auto;" src="../images/dbms/42/9.png" alt="" width="550" height="180" /></p>
<p>Suppose we have a new student Bryan. Where will he fit in the file? He will fit in the 1<sup>st</sup> leaf node. Since this leaf node is not full, we can easily add him in the node.</p>
<p><img style="width: auto; max-width: 100%; height: auto;" src="../images/dbms/42/10.png" alt="" width="534" height="167" /></p>
<p>But what happens if we want to insert another student Ben to this file? Some re-arrangement to the nodes is needed to maintain the balance of the file.</p>
<p><img style="width: auto; max-width: 100%; height: auto;" src="../images/dbms/42/11.png" alt="" width="523" height="169" /></p>
<p>Same thing happens when we perform delete too.</p>
<h2>Benefits of B+ Tree index files</h2>
<ul type="disc">
<li>As the file grows in the database, the performance remains the same. It does not degrade like in ISAM. This is because all the records are maintained at leaf node and all the nodes are at equi-distance from root. In addition, if there is any overflow, it automatically re-organizes the structure.</li>
<li>Even though insertion and deletion are little complicated, it can be done in fraction of seconds.</li>
<li>Leaf node allows only partial/ half filled, since records are larger than pointers.</li>
</ul>
<h2>B Tree index Files</h2>
<p>B tree index file is similar to B+ tree index files, but it uses binary search concepts. In this method, each root will branch to only two nodes and each intermediary node will also have the data. And leaf node will have lowest level of data. However, in this method also, records will be sorted. Since all intermediary nodes also have records, it reduces the traversing till leaf node for the data. A simple B tree can be represented as below:</p>
<p><img style="width: auto; max-width: 100%; height: auto;" src="../images/dbms/42/12.png" alt="" width="525" height="165" /></p>
<p>See the difference between this tree structure and B+ tree for the same example above. Here there is no repetition or pointers till leaf node. All the records are stored in all the nodes. If we need to insert any record, it will be done as B+ tree index files, but it will make sure that each node will branch only to two nodes. If there is not enough space in any of the node, it will split the node and store the records.</p



<div id="bottomnextup">
<a class="next" href="dbms-er-model-concept">next &rarr;</a>
<a class="next" href="dbms-data-independence">&larr; prev</a>
</div>


<br/><br/>
</td></tr>
</table>
    </div>

</body>

</html> 