<html>
<head>
<title>NETCODE</title>

<meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.0/css/bootstrap.min.css">
  <link href="https://fonts.googleapis.com/css?family=Montserrat" rel="stylesheet">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.0/js/bootstrap.min.js"></script>

<script src="jquery-3.4.1.min.js"></script>

<style>
.con .homecontent{
	float:left;
     background:#dfe5ed;
     margin:4;
}
element.style {
}
.ddsmoothmenu {
    font-size: 13px;
    background-color: #787c7d;
    width: 100%;
}

div {
    display: block;
}
html {
    color: -internal-root-color;
}
.ddsmoothmenu ul li a {
    display: block;
    background-color: #787c7d;
    color: #fff;
    font-size: 15px;
    padding: .9em;
    text-decoration: none;
}
a {
    color: green;
    text-decoration: none;
}
.ddsmoothmenu ul li a:hover{
	display: block;
	background-color:#4d5354;
}

.ddsmoothmenu ul {
    z-index: 100;
    margin: 0;
    padding: 0;
    list-style-type: none;
}
ul, ul.points {
    list-style: circle;
    line-height: 150%;
}
ul {
    list-style-type: disc;
}
.ddsmoothmenu {
    font-size: 13px;
    background-color: #787c7d;
    width: 100%;
}

  #link {
        height: 46px;
        font-weight: 700;
        overflow: hidden
    }

element.style {
    clear: both;
}
div {
    display: block;
}
div ul li.cen
{
	float:left;
}
html {
    color: -internal-root-color;
}
.homecontent {
    
    font-size: 14px;
    padding: 15px;
    width:  300px;
    height: 174px;
    border-radius: 2px 25px 2px 25px;
    -webkit-box-shadow: -2px 10px 22px -16px rgba(0,0,0,.75);
    -moz-box-shadow: -2px 10px 22px -16px rgba(0,0,0,.75);
    box-shadow: 7px 10px 22px -6px rgba(0,0,0,.75);
}

#innerfooter div, #interview h2, #uh3, .homecontent, div#q h2, div.q h2 {
    text-align: center;
}
user agent stylesheet
.homecontent div {
    display: block;
}
.homecontent div a {
    color: green;
    text-decoration: none;
}
user agent stylesheet
a:-webkit-any-link {
    color: -webkit-link;
    cursor: pointer;
}
#city td {
    color: #000;
    line-height: 23px;
    margin-left: 20px;
}
#city td, #city ul {
    font: 13px verdana,helvetica,arial,sans-serif;
}
user agent stylesheet
table {
    border-collapse: separate;
    border-spacing: 2px;
}
/*button next & previes */
#bottomnextup a {
    font: 13px/1.5 times new roman;
    background-color: #787c7d;
    float: right;
    margin-top:5px;
    padding: 6px 25px;
    color: #fff;
    font-weight: 700;
    text-decoration: none;
    margin-left: 7px;
}
#bottomnextup a:hover{
    display: block;
    background-color:#4d5354;   
}
.Content_Only
{
    background-color:#e5ecee;
    margin-left: inherit;
    margin-right: auto;
}

@media screen and (min-width: 700px){
.Content_Only {
    margin-left:200px;
    margin-right: 100px;
}

.h3 {
    font-size: 21px;
}
.h3, .h4 {
    font-family: erdana,helvetica,arial,sans-serif;
    color: #610B4B;
}
.h1, .h3 {
    font-weight: 400;
}
h1, h2, h3 {
    line-height: 1.3em;
}

h3 {
    display: block;
    font-size: 1.17em;
    margin-block-start: 1em;
    margin-block-end: 1em;
    margin-inline-start: 0px;
    margin-inline-end: 0px;
    font-weight: bold;
}
</style>

</head>
<body>

<div id="link" style="clear:both"> 
	<div class="ddsmoothmenu"><ul>
        <li class="cen"><a href="#">NETCODE</a></li>
		<li class="cen"><a href="https://www.javatpoint.com">DS</a></li>
		<li class="cen"><a href="python-tutorial">DAA</a></li>
		<li class="cen"><a href="java-tutorial">OS</a></li>
		<li class="cen"><a href="php-tutorial">C.Network</a></li>
		<li class="cen"><a href="javascript-tutorial">Compiler D:</a></li>
        <li class="cen"><a href="javascript-tutorial">COA</a></li>
        <li class="cen"><a href="javascript-tutorial">D.Math</a></li>
        <li class="cen"><a href="javascript-tutorial">E.Hacking</a></li>
        <li class="cen"><a href="javascript-tutorial">C.Graphics</a></li>
        <li class="cen"><a href="javascript-tutorial">Software E.</a></li>
        <li class="cen"><a href="javascript-tutorial">Web Tech</a></li>
        <li class="cen"><a href="javascript-tutorial">Cyber Sec</a></li>
        <li class="cen"><a href="javascript-tutorial">Automata </a></li>
        <li class="cen"><a href="javascript-tutorial">C</a></li>
        <li class="cen"><a href="javascript-tutorial">C++</a></li>
        <li class="cen"><a href="javascript-tutorial">Java</a></li>
        <li class="cen"><a href="javascript-tutorial">.Net</a></li>
        <li class="cen"><a href="javascript-tutorial">Python</a></li>
        <li class="cen"><a href="javascript-tutorial">Programs</a></li>
        <li class="cen"><a href="javascript-tutorial">Control S.</a></li>

	</ul><br style="clear: left"></div> 
</div>
<div class="Content_Only">
    <table>
<tr><td>

<div id="bottomnextup">
<a class="next" href="dbms-er-model-concept">next &rarr;</a>
<a class="next" href="dbms-data-independence">&larr; prev</a>
</div>


<h1 class="h1">Indexing in DBMS</h1>
<ul class="points">
<li>Indexing is used to optimize the performance of a database by minimizing the number of disk accesses required when a query is processed. </li> 
<li>The index is a type of data structure. It is used to locate and access the data in a database table quickly.</li>
</ul>
<h2 class="h2">Index structure:</h2>
<p>Indexes can be created using some database columns.</p>
<img src="https://static.javatpoint.com/dbms/images/dbms-indexing-in-dbms.png" alt="DBMS Indexing in DBMS"/>
<br>
<ul class="points">
<li>The first column of the database is the search key that contains a copy of the primary key or candidate key of the table. The values of the primary key are stored in sorted order so that the corresponding data can be accessed easily. </li> 
<li>The second column of the database is the data reference. It contains a set of pointers holding the address of the disk block where the value of the particular key can be found.</li>
</ul>
<h2 class="h2">Indexing Methods</h2>
<img src="https://static.javatpoint.com/dbms/images/dbms-indexing-in-dbms_2.png" alt="DBMS Indexing in DBMS"/>
<h2 class="h3">Ordered indices</h2>
<p>The indices are usually sorted to make searching faster. The indices which are sorted are known as ordered indices.</p>
<p><strong>Example</strong>: Suppose we have an employee table with thousands of record and each of which is 10 bytes long. If their IDs start with 1, 2, 3....and so on and we have to search student with ID-543.</p>
<ul class="points">
<li>In the case of a database with no index, we have to search the disk block from starting till it reaches 543. The DBMS will read the record after reading 543*10=5430 bytes.</li> 
<li>In the case of an index, we will search using indexes and the DBMS will read the record after reading 542*2= 1084 bytes which are very less compared to the previous case.</li>
</ul>
<h2 class="h3">Primary Index</h2>
<ul class="points">
<li>If the index is created on the basis of the primary key of the table, then it is known as primary indexing. These primary keys are unique to each record and contain 1:1 relation between the records.</li> 
<li>As primary keys are stored in sorted order, the performance of the searching operation is quite efficient. </li>
<li>The primary index can be classified into two types: Dense index and Sparse index.</li>
</ul>
<h2 class="h3">Dense index</h2>
<ul class="points">
<li>The dense index contains an index record for every search key value in the data file. It makes searching faster.</li>
<li>In this, the number of records in the index table is same as the number of records in the main table.</li> 
<li>It needs more space to store index record itself. The index records have the search key and a pointer to the actual record on the disk.</li>
</ul>
<img src="https://static.javatpoint.com/dbms/images/dbms-indexing-in-dbms_3.png" alt="DBMS Indexing in DBMS"/>
<h2 class="h3">Sparse index</h2>
<ul class="points">
<li>In the data file, index record appears only for a few items. Each item points to a block.</li>
<li>In this, instead of pointing to each record in the main table, the index points to the records in the main table in a gap.</li>
</ul>
<img src="https://static.javatpoint.com/dbms/images/dbms-indexing-in-dbms_4.png" alt="DBMS Indexing in DBMS"/>
<h2 class="h3">Clustering Index</h2>
<ul class="points">
<li>A clustered index can be defined as an ordered data file. Sometimes the index is created on non-primary key columns which may not be unique for each record.</li>
<li>In this case, to identify the record faster, we will group two or more columns to get the unique value and create index out of them. This method is called a clustering index.</li>
<li>The records which have similar characteristics are grouped, and indexes are created for these group.</li>
</ul>
<p><strong>Example</strong>: suppose a company contains several employees in each department. Suppose we use a clustering index, where all employees which belong to the same Dept_ID are considered within a single cluster, and index pointers point to the cluster as a whole.  Here Dept_Id is a non-unique key.</p>
<img src="https://static.javatpoint.com/dbms/images/dbms-indexing-in-dbms_5.png" alt="DBMS Indexing in DBMS"/>
<br>
<p>The previous schema is little confusing because one disk block is shared by records which belong to the different cluster. If we use separate disk block for separate clusters, then it is called better technique.</p>
<img src="https://static.javatpoint.com/dbms/images/dbms-indexing-in-dbms_6.png" alt="DBMS Indexing in DBMS"/>
<h2 class="h3">Secondary Index</h2>
<p>In the sparse indexing, as the size of the table grows, the size of mapping also grows. These mappings are usually kept in the primary memory so that address fetch should be faster. Then the secondary memory searches the actual data based on the address got from mapping. If the mapping size grows then fetching the address itself becomes slower. In this case, the sparse index will not be efficient. To overcome this problem, secondary indexing is introduced.</p>  
<p>In secondary indexing, to reduce the size of mapping, another level of indexing is introduced. In this method, the huge range for the columns is selected initially so that the mapping size of the first level becomes small. Then each range is further divided into smaller ranges. The mapping of the first level is stored in the primary memory, so that address fetch is faster. The mapping of the second level and actual data are stored in the secondary memory (hard disk).</p>
<img src="https://static.javatpoint.com/dbms/images/dbms-indexing-in-dbms_7.png" alt="DBMS Indexing in DBMS"/>
<p><strong>For example:</strong></p>
<ul class="points">
<li>If you want to find the record of roll 111 in the diagram, then it will search the highest entry which is smaller than or equal to 111 in the first level index. It will get 100 at this level. </li>
<li>Then in the second index level, again it does max (111) &lt;= 111 and gets 110. Now using the address 110, it goes to the data block and starts searching each record till it gets 111. </li>
<li>This is how a search is performed in this method. Inserting, updating or deleting is also done in the same manner.</li>
</ul>

<br>
<div class="nexttopicdiv">
<span class="nexttopictext">Next Topic</span><span class="nexttopiclink"><a href="dbms-b-plus-tree">B+ Tree</a></span>
</div>
<!-- link -->
<br/><br/>




<div id="bottomnextup">
<a class="next" href="dbms-er-model-concept">next &rarr;</a>
<a class="next" href="dbms-data-independence">&larr; prev</a>
</div>


<br/><br/>
</td></tr>
</table>
    </div>

</body>

</html> 