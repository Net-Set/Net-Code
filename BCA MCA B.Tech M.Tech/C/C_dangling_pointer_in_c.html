<html>
<head>
<title>NETCODE</title>

<style>
    * {
  box-sizing: border-box;
  user-select: none;
}
body {
  color:black;
  line-height: 1.5;
  margin:0;
  
}
.info{
  text-align: center;
  font-size:50px;
  
  background-color:#e5ecee;
  text-transform: capitalize;
}
.nav-header .logo {
  width: 10%;
}
.nav-header nav {
  width: 100%;
}
header {
  background: #787c7d;
  color: white;
}
.nav-header {
  border-radius: 5px;
}
.logo {
  text-align: center;
  border-right: 1px;
  padding: 12px 24px 13px;
}

.item {
  padding: 12px 16px 13px;
}
.item:hover{
	background-color:;#8f8f8f;
}
.item:not(:last-child) {
  border-right: 1px solid #7e7e7e;
}
header,
nav {
  font-size: 0;
}
.item {
  font-size: 24px;
}
.logo,
.item,
.middle {
  display: inline-block;
  vertical-align: middle;
}
  .scroll {
    white-space: nowrap;
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
    -ms-overflow-style: -ms-autohiding-scrollbar;
  }
  .scroll::-webkit-scrollbar {
    display: none;
  }
@media (max-width: 765px) {
  .item {
    font-size: 14px;
  }
}
.con .homecontent{
  float:left;
     background:#dfe5ed;
     margin:4;
}
element.style {
}
.ddsmoothmenu {
    font-size: 13px;
    background-color: #787c7d;
    width: 100%;
}

div {
    display: block;
}
html {
    color: -internal-root-color;
}
.ddsmoothmenu ul li a {
    display: block;
    background-color: #787c7d;
    color: #fff;
    font-size: 15px;
    padding: .9em;
    text-decoration: none;
}
a {
    color: green;
    text-decoration: none;
}
.ddsmoothmenu ul li a:hover{
  display: block;
  background-color:#4d5354;
}

.ddsmoothmenu ul {
    z-index: 100;
    margin: 0;
    padding: 0;
    list-style-type: none;
}
ul, ul.points {
    list-style: circle;
    line-height: 150%;
}
ul {
    list-style-type: disc;
}
.ddsmoothmenu {
    font-size: 13px;
    background-color: #787c7d;
    width: 100%;
}

  #link {
        height: 46px;
        font-weight: 700;
        overflow: hidden
    }

element.style {
    clear: both;
}
div {
    display: block;
}
div ul li.cen
{
  float:left;
}
html {
    color: -internal-root-color;
}
.homecontent {
    
    font-size: 14px;
    padding: 15px;
    width:  300px;
    height: 174px;
    border-radius: 2px 25px 2px 25px;
    -webkit-box-shadow: -2px 10px 22px -16px rgba(0,0,0,.75);
    -moz-box-shadow: -2px 10px 22px -16px rgba(0,0,0,.75);
    box-shadow: 7px 10px 22px -6px rgba(0,0,0,.75);
}

#innerfooter div, #interview h2, #uh3, .homecontent, div#q h2, div.q h2 {
    text-align: center;
}
user agent stylesheet
.homecontent div {
    display: block;
}
.homecontent div a {
    color: green;
    text-decoration: none;
}
user agent stylesheet
a:-webkit-any-link {
    color: -webkit-link;
    cursor: pointer;
}
.code
{
  max-width: 100%;
  height:auto;
}
#city td {
    color: #000;
    line-height: 23px;
    margin-left: 20px;
}
#city td, #city ul {
    font: 13px verdana,helvetica,arial,sans-serif;
}
user agent stylesheet
table {
    border-collapse: separate;
    border-spacing: 2px;
}
/*button next & previes */
#bottomnextup a {
    font: 13px/1.5 times new roman;
    background-color: #787c7d;
    float: right;
    margin-top:5px;
    padding: 6px 25px;
    color: #fff;
    font-weight: 700;
    text-decoration: none;
    margin-left: 7px;
}
#bottomnextup a:hover{
    display: block;
    background-color:#4d5354;   
}
.Content_Only
{
    background-color:#e5ecee;
    margin-left: inherit;
    margin-right: inherit;
}

@media screen and (min-width: 700px){
.Content_Only {
    margin-left:200px;
    margin-right: 100px;
}

textarea {
  border:1px solid #ddd;
 width: 100%; 
 height: 150px; 

}
}
.codeblock {
    width: 100%;
    margin-bottom: 8px;
    font-family: verdana;
    padding-left: 0;
    border-left: 4px solid #8e9eac;
    -moz-box-shadow: 6px 3px 8px #d4d4d4;
    -webkit-box-shadow: 6px 3px 8px #d4d4d4;
    box-shadow: 6px 3px 8px #d4d4d4;
}

.dp-highlighter {
    width: auto;
    overflow: hidden;
    margin: 8px 0!important;
    padding-top: 0;
}

.h3 {
    font-size: 21px;
}
.h3, .h4 {
    font-family: erdana,helvetica,arial,sans-serif;
    color: #610B4B;
}
.h1, .h3 {
    font-weight: 400;
}
h1, h2, h3 {
    line-height: 1.3em;
}

h3 {
    display: block;
    font-size: 1.17em;
    margin-block-start: 1em;
    margin-block-end: 1em;
    margin-inline-start: 0px;
    margin-inline-end: 0px;
    font-weight: bold;
}
img
{
  max-width:100%;
  height:auto;
}

.alt td, .alt th {
  border: 1px solid #ddd;
  padding: 8px;
}

textarea {
  border:1px solid #ddd;
 width: 90%; 
 height: 150px; 

}



.sticky {
  position: fixed;
  top: 0;
  width: 100%;
}

.Content_Only{
  padding-top: 60px;
}

</style>

</head>
<body>
<div class="container" >
    <div class="info">NETCODE</div>
  <header class="nav-header">
    <nav class="middle scroll">
    	<span class="item" style="padding: 11px 24px 13px;background-color:black;">NETCODE</span>
    
      <span class="item" style="">Home</span>
      <span class="item">About</span>
      <span class="item">Portfolio</span>
      <span class="item">Pricing</span>
      <span class="item">Services</span>
      <span class="item">Contact</span>
      <span class="item">Blog</span>
      <span class="item">Help</span>

        <span class="item">About</span>
      <span class="item">Portfolio</span>
      <span class="item">Pricing</span>
      <span class="item">Services</span>
      <span class="item">About</span>
      <span class="item">Portfolio</span>
      <span class="item">Pricing</span>
      <span class="item">Services</span>
    
    </nav>
  </header>
</div>
  <script>

  </script>
<div class="Content_Only">
    <table>
<tr><td>


<div id="bottomnextup">
<a class="next" href="C_sizeof_operator_in_c.html">next &rarr;</a>
<a class="next" href="C_pointer_arithmetic.html">&larr; prev</a>
</div>



<h1 class="h1">Dangling Pointers in C</h1>
<p>The most common bugs related to pointers and memory management is dangling/wild pointers. Sometimes the programmer fails to initialize the pointer with a valid address, then this type of initialized pointer is known as a dangling pointer in C.</p>
<p>Dangling pointer occurs at the time of the object destruction when the object is deleted or de-allocated from memory without modifying the value of the pointer. In this case, the pointer is pointing to the memory, which is de-allocated. The dangling pointer can point to the memory, which contains either the program code or the code of the operating system. If we assign the value to this pointer, then it overwrites the value of the program code or operating system instructions; in such cases, the program will show the undesirable result or may even crash. If the memory is re-allocated to some other process, then we dereference the dangling pointer will cause the segmentation faults.</p>
<p class="pq"><strong>Let's observe the following examples.</strong></p>
<img src="https://static.javatpoint.com/cpages/images/dangling-pointers-in-c.png" alt="Dangling Pointers in C"/>
<p>In the above figure, we can observe that the <strong>Pointer 3</strong> is a dangling pointer. <strong>Pointer 1</strong> and <strong>Pointer 2</strong> are the pointers that point to the allocated objects, i.e., Object 1 and Object 2, respectively. <strong>Pointer 3</strong> is a dangling pointer as it points to the de-allocated object.</p>
<p class="pq"><strong>Let's understand the dangling pointer through some C programs.</strong></p>
<p><strong>Using free() function to de-allocate the memory.</strong></p>
<div class="codeblock"><textarea name="code" class="java">
#include &lt;stdio.h&gt;
int main()
{
   int *ptr=(int *)malloc(sizeof(int));
   int a=560;
   ptr=&a;
   free(ptr);
   return 0;
}
</textarea></div>
<p>In the above code, we have created two variables, i.e., *ptr and a where 'ptr' is a pointer and 'a' is a integer variable. The *ptr is a pointer variable which is created with the help of <strong>malloc()</strong> function. As we know that malloc() function returns void, so we use int * to convert void pointer into int pointer.</p>
<p>The statement <strong>int *ptr=(int *)malloc(sizeof(int));</strong> will allocate the memory with 4 bytes shown in the below image:</p>
<img src="https://static.javatpoint.com/cpages/images/dangling-pointers-in-c2.png" alt="Dangling Pointers in C"/>
<p>The statement <strong>free(ptr)</strong> de-allocates the memory as shown in the below image with a cross sign, and 'ptr' pointer becomes dangling as it is pointing to the de-allocated memory.</p>
<img src="https://static.javatpoint.com/cpages/images/dangling-pointers-in-c3.png" alt="Dangling Pointers in C"/>
<p>If we assign the NULL value to the 'ptr', then 'ptr' will not point to the deleted memory. Therefore, we can say that ptr is not a dangling pointer, as shown in the below image:</p>
<img src="https://static.javatpoint.com/cpages/images/dangling-pointers-in-c4.png" alt="Dangling Pointers in C"/>
<p class="pq"><strong>Variable goes out of the scope</strong></p>
<p>When the variable goes out of the scope then the pointer pointing to the variable becomes a <strong>dangling pointer.</strong></p>
<div class="codeblock"><textarea name="code" class="java">
#include&lt;stdio.h&gt;
int main()
{
    char *str;
    {
        char a = ?A?;
        str = &a;
    }
    // a falls out of scope 
    // str is now a dangling pointer 
    printf("%s", *str);
}
</textarea></div>
<p><strong>In the above code, we did the following steps:</strong></p>
<ul class="points">
<li>First, we declare the pointer variable named 'str'.</li>
<li>In the inner scope, we declare a character variable. The str pointer contains the address of the variable 'a'.</li>
<li>When the control comes out of the inner scope, 'a' variable will no longer be available, so str points to the de-allocated memory. It means that the str pointer becomes the dangling pointer.</li>
</ul>
<p class="pq"><strong>Function call</strong></p>
<p>Now, we will see how the pointer becomes dangling when we call the function.</p>
<p><strong>Let's understand through an example.</strong></p>
<div class="codeblock"><textarea name="code" class="java">
   #include &lt;stdio.h&gt;
    int *fun(){
    int y=10;
    return &y;
  }
int main()
{
int *p=fun();
printf("%d", *p);
return 0;
}
</textarea></div>
<p><strong>In the above code, we did the following steps:</strong></p>
<ul class="points">
<li>First, we create the <strong>main()</strong> function in which we have declared <strong>'p'</strong> pointer that contains the return value of the <strong>fun()</strong>.</li>
<li>When the <strong>fun()</strong> is called, then the control moves to the context of the <strong>int *fun(),</strong> the <strong>fun() </strong>returns the address of the 'y' variable.</li>
<li>When control comes back to the context of the <strong>main()</strong> function, it means the variable <strong>'y'</strong> is no longer available. Therefore, we can say that the <strong>'p'</strong> pointer is a dangling pointer as it points to the de-allocated memory.</li>
</ul>
<p><strong>Output</strong></p>
<img src="https://static.javatpoint.com/cpages/images/dangling-pointers-in-c5.png" alt="Dangling Pointers in C"/>
<p><strong>Let's represent the working of the above code diagrammatically.</strong></p>
<img src="https://static.javatpoint.com/cpages/images/dangling-pointers-in-c6.png" alt="Dangling Pointers in C"/>
<p><strong>Let's consider another example of a dangling pointer.</strong></p>
<div class="codeblock"><textarea name="code" class="java">
#include &lt;stdio.h&gt;
int *fun()
{
    static int y=10;
    return &y;
}
int main()
{
   int *p=fun();
   printf("%d", *p);
    return 0;
}
</textarea></div>
<p>The above code is similar to the previous one but the only difference is that the variable 'y' is static. We know that static variable stores in the global memory.</p>
<p><strong>Output</strong></p>
<img src="https://static.javatpoint.com/cpages/images/dangling-pointers-in-c7.png" alt="Dangling Pointers in C"/>
<p>Now, we represent the working of the above code diagrammatically.</p>
<img src="https://static.javatpoint.com/cpages/images/dangling-pointers-in-c8.png" alt="Dangling Pointers in C"/>
<p>The above diagram shows the stack memory. First, <strong>the fun()</strong> function is called, then the control moves to the context of the <strong>int *fun().</strong> As 'y' is a static variable, so it stores in the global memory; Its scope is available throughout the program. When the address value is returned, then the control comes back to the context of the <strong>main().</strong> The pointer 'p' contains the address of 'y', i.e., 100. When we print the value of '*p', then it prints the value of 'y', i.e., 10. Therefore, we can say that the pointer 'p' is not a dangling pointer as it contains the address of the variable which is stored in the global memory.</p>
<p class="pq"><strong>Avoiding Dangling Pointer Errors</strong></p>
<p>The dangling pointer errors can be avoided by initializing the pointer to the <strong>NULL</strong> value. If we assign the <strong>NULL</strong> value to the pointer, then the pointer will not point to the de-allocated memory. Assigning <strong>NULL</strong> value to the pointer means that the pointer is not pointing to any memory location.</p>

<hr/>
<div class="nexttopicdiv">
<span class="nexttopictext">Next Topic</span><span class="nexttopiclink"><a href="size-of-operator-in-c">sizeof() operator in C</a></span>
</div>
<!-- link -->
<br/><br/>




<div id="bottomnextup">
<a class="next" href="C_sizeof_operator_in_c.html">next &rarr;</a>
<a class="next" href="C_pointer_arithmetic.html">&larr; prev</a>
</div>


<br/><br/>
</td></tr>
</table>
    </div>
<!--
	*<script src="C:\Users\hp\Desktop\NETCODE\java.js"></script><script> *dp.SyntaxHighlighter.HighlightAll('code'); </script>-->

 
<script src="https://static.javatpoint.com/js/shcoreandbrush.js"></script><script> dp.SyntaxHighlighter.HighlightAll('code'); </script>
<script src="https://static.javatpoint.com/lazysizes.min.js" async></script>
</body>

</html> 